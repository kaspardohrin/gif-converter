{"ast":null,"code":"var _toConsumableArray = require(\"C:/Users/kaspar/Documents/cmgt/specialisatie-block/react-tsc/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"C:/Users/kaspar/Documents/cmgt/specialisatie-block/react-tsc/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/kaspar/Documents/cmgt/specialisatie-block/react-tsc/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"C:/Users/kaspar/Documents/cmgt/specialisatie-block/react-tsc/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _objectWithoutProperties = require(\"C:/Users/kaspar/Documents/cmgt/specialisatie-block/react-tsc/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _require = require('./config'),\n    defaultArgs = _require.defaultArgs,\n    baseOptions = _require.baseOptions;\n\nvar _require2 = require('./utils/log'),\n    setLogging = _require2.setLogging,\n    setCustomLogger = _require2.setCustomLogger,\n    log = _require2.log;\n\nvar parseProgress = require('./utils/parseProgress');\n\nvar parseArgs = require('./utils/parseArgs');\n\nvar _require3 = require('./node'),\n    defaultOptions = _require3.defaultOptions,\n    getCreateFFmpegCore = _require3.getCreateFFmpegCore;\n\nvar _require4 = require('../package.json'),\n    version = _require4.version;\n\nvar NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = function () {\n  var _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _baseOptions$defaultO = _objectSpread(_objectSpread(_objectSpread({}, baseOptions), defaultOptions), _options),\n      logging = _baseOptions$defaultO.log,\n      logger = _baseOptions$defaultO.logger,\n      optProgress = _baseOptions$defaultO.progress,\n      options = _objectWithoutProperties(_baseOptions$defaultO, [\"log\", \"logger\", \"progress\"]);\n\n  var Core = null;\n  var ffmpeg = null;\n  var runResolve = null;\n  var running = false;\n  var progress = optProgress;\n\n  var detectCompletion = function detectCompletion(message) {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n\n  var parseMessage = function parseMessage(_ref) {\n    var type = _ref.type,\n        message = _ref.message;\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n\n\n  var load = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var createFFmpegCore;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              log('info', 'load ffmpeg-core');\n\n              if (!(Core === null)) {\n                _context.next = 13;\n                break;\n              }\n\n              log('info', 'loading ffmpeg-core');\n              _context.next = 5;\n              return getCreateFFmpegCore(options);\n\n            case 5:\n              createFFmpegCore = _context.sent;\n              _context.next = 8;\n              return createFFmpegCore({\n                printErr: function printErr(message) {\n                  return parseMessage({\n                    type: 'fferr',\n                    message: message\n                  });\n                },\n                print: function print(message) {\n                  return parseMessage({\n                    type: 'ffout',\n                    message: message\n                  });\n                },\n                locateFile: function locateFile(path, prefix) {\n                  if (typeof window !== 'undefined' && typeof window.FFMPEG_CORE_WORKER_SCRIPT !== 'undefined' && path.endsWith('ffmpeg-core.worker.js')) {\n                    return window.FFMPEG_CORE_WORKER_SCRIPT;\n                  }\n\n                  return prefix + path;\n                }\n              });\n\n            case 8:\n              Core = _context.sent;\n              ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n              log('info', 'ffmpeg-core loaded');\n              _context.next = 14;\n              break;\n\n            case 13:\n              throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function load() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /*\n   * Determine whether the Core is loaded.\n   */\n\n\n  var isLoaded = function isLoaded() {\n    return Core !== null;\n  };\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n\n\n  var run = function run() {\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    log('info', \"run ffmpeg command: \".concat(_args.join(' ')));\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise(function (resolve) {\n        var args = [].concat(_toConsumableArray(defaultArgs), _args).filter(function (s) {\n          return s.length !== 0;\n        });\n        runResolve = resolve;\n        ffmpeg.apply(void 0, _toConsumableArray(parseArgs(Core, args)));\n      });\n    }\n  };\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n\n\n  var FS = function FS(method) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    log('info', \"run FS.\".concat(method, \" \").concat(args.map(function (arg) {\n      return typeof arg === 'string' ? arg : \"<\".concat(arg.length, \" bytes binary file>\");\n    }).join(' ')));\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      var ret = null;\n\n      try {\n        var _Core$FS;\n\n        ret = (_Core$FS = Core.FS)[method].apply(_Core$FS, args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(\"ffmpeg.FS('readdir', '\".concat(args[0], \"') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')\"));\n        } else if (method === 'readFile') {\n          throw Error(\"ffmpeg.FS('readFile', '\".concat(args[0], \"') error. Check if the path exists\"));\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n\n      return ret;\n    }\n  };\n\n  var setProgress = function setProgress(_progress) {\n    progress = _progress;\n  };\n\n  var setLogger = function setLogger(_logger) {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n  log('info', \"use ffmpeg.wasm v\".concat(version));\n  return {\n    setProgress: setProgress,\n    setLogger: setLogger,\n    setLogging: setLogging,\n    load: load,\n    isLoaded: isLoaded,\n    run: run,\n    FS: FS\n  };\n};","map":{"version":3,"sources":["C:/Users/kaspar/Documents/cmgt/specialisatie-block/react-tsc/node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js"],"names":["require","defaultArgs","baseOptions","setLogging","setCustomLogger","log","parseProgress","parseArgs","defaultOptions","getCreateFFmpegCore","version","NO_LOAD","Error","module","exports","_options","logging","logger","optProgress","progress","options","Core","ffmpeg","runResolve","running","detectCompletion","message","parseMessage","type","load","createFFmpegCore","printErr","print","locateFile","path","prefix","window","FFMPEG_CORE_WORKER_SCRIPT","endsWith","cwrap","isLoaded","run","_args","join","Promise","resolve","args","filter","s","length","FS","method","map","arg","ret","e","setProgress","_progress","setLogger","_logger"],"mappings":"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","sourcesContent":["const { defaultArgs, baseOptions } = require('./config');\nconst { setLogging, setCustomLogger, log } = require('./utils/log');\nconst parseProgress = require('./utils/parseProgress');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      const createFFmpegCore = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined'\n            && typeof window.FFMPEG_CORE_WORKER_SCRIPT !== 'undefined'\n            && path.endsWith('ffmpeg-core.worker.js')) {\n            return window.FFMPEG_CORE_WORKER_SCRIPT;\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    FS,\n  };\n};\n"]},"metadata":{},"sourceType":"script"}